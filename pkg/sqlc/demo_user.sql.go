// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: demo_user.sql

package sqlc

import (
	"context"
)

const demoUserCreate = `-- name: DemoUserCreate :one
INSERT INTO demo_users (demo_id, user_id)
VALUES ($1, $2)
RETURNING id
`

type DemoUserCreateParams struct {
	DemoID int32
	UserID int32
}

func (q *Queries) DemoUserCreate(ctx context.Context, arg DemoUserCreateParams) (int32, error) {
	row := q.db.QueryRow(ctx, demoUserCreate, arg.DemoID, arg.UserID)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const demoUserDeleteByDemoUser = `-- name: DemoUserDeleteByDemoUser :exec
UPDATE demo_users
SET deleted_at = NOW()
WHERE demo_id = $1 AND user_id = $2
`

type DemoUserDeleteByDemoUserParams struct {
	DemoID int32
	UserID int32
}

func (q *Queries) DemoUserDeleteByDemoUser(ctx context.Context, arg DemoUserDeleteByDemoUserParams) error {
	_, err := q.db.Exec(ctx, demoUserDeleteByDemoUser, arg.DemoID, arg.UserID)
	return err
}

const demoUserGetByDemoUser = `-- name: DemoUserGetByDemoUser :one
SELECT id, demo_id, user_id, deleted_at
FROM demo_users
WHERE demo_id = $1 AND user_id = $2
`

type DemoUserGetByDemoUserParams struct {
	DemoID int32
	UserID int32
}

func (q *Queries) DemoUserGetByDemoUser(ctx context.Context, arg DemoUserGetByDemoUserParams) (DemoUser, error) {
	row := q.db.QueryRow(ctx, demoUserGetByDemoUser, arg.DemoID, arg.UserID)
	var i DemoUser
	err := row.Scan(
		&i.ID,
		&i.DemoID,
		&i.UserID,
		&i.DeletedAt,
	)
	return i, err
}
