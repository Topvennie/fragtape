// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: demo.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const demoCreate = `-- name: DemoCreate :one
INSERT INTO demos (user_id, source, source_id, status, file_id)
VALUES ($1, $2, $3, 'queued_parse', $4)
RETURNING id
`

type DemoCreateParams struct {
	UserID   int32
	Source   DemoSource
	SourceID pgtype.Text
	FileID   pgtype.Text
}

func (q *Queries) DemoCreate(ctx context.Context, arg DemoCreateParams) (int32, error) {
	row := q.db.QueryRow(ctx, demoCreate,
		arg.UserID,
		arg.Source,
		arg.SourceID,
		arg.FileID,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const demoDelete = `-- name: DemoDelete :exec
UPDATE demos
SET deleted_at = NOW()
WHERE id = $1
`

func (q *Queries) DemoDelete(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, demoDelete, id)
	return err
}

const demoGet = `-- name: DemoGet :one
SELECT id, user_id, source, source_id, file_id, status, attempts, error, created_at, status_updated_at, deleted_at
FROM demos
WHERE id = $1
`

func (q *Queries) DemoGet(ctx context.Context, id int32) (Demo, error) {
	row := q.db.QueryRow(ctx, demoGet, id)
	var i Demo
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Source,
		&i.SourceID,
		&i.FileID,
		&i.Status,
		&i.Attempts,
		&i.Error,
		&i.CreatedAt,
		&i.StatusUpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const demoGetByStatus = `-- name: DemoGetByStatus :many
SELECT id, user_id, source, source_id, file_id, status, attempts, error, created_at, status_updated_at, deleted_at
FROM demos
WHERE status = $1 AND deleted_at IS NULL
ORDER BY created_at ASC
`

func (q *Queries) DemoGetByStatus(ctx context.Context, status DemoStatus) ([]Demo, error) {
	rows, err := q.db.Query(ctx, demoGetByStatus, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Demo
	for rows.Next() {
		var i Demo
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Source,
			&i.SourceID,
			&i.FileID,
			&i.Status,
			&i.Attempts,
			&i.Error,
			&i.CreatedAt,
			&i.StatusUpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const demoGetByStatusUpdateAtomic = `-- name: DemoGetByStatusUpdateAtomic :many
WITH cte AS (
  SELECT d.id
  FROM demos d
  WHERE d.status = $2
  ORDER BY d.attempts, d.created_at
  FOR UPDATE SKIP LOCKED
  LIMIT $3
)
UPDATE demos
SET
  status = $1,
  attempts = attempts + 1,
  status_updated_at = NOW()
WHERE id in (SELECT id from cte)
RETURNING id, user_id, source, source_id, file_id, status, attempts, error, created_at, status_updated_at, deleted_at
`

type DemoGetByStatusUpdateAtomicParams struct {
	NewStatus DemoStatus
	OldStatus DemoStatus
	Amount    int32
}

func (q *Queries) DemoGetByStatusUpdateAtomic(ctx context.Context, arg DemoGetByStatusUpdateAtomicParams) ([]Demo, error) {
	rows, err := q.db.Query(ctx, demoGetByStatusUpdateAtomic, arg.NewStatus, arg.OldStatus, arg.Amount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Demo
	for rows.Next() {
		var i Demo
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Source,
			&i.SourceID,
			&i.FileID,
			&i.Status,
			&i.Attempts,
			&i.Error,
			&i.CreatedAt,
			&i.StatusUpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const demoGetByUser = `-- name: DemoGetByUser :many
SELECT id, user_id, source, source_id, file_id, status, attempts, error, created_at, status_updated_at, deleted_at
FROM demos
WHERE user_id = $1 AND deleted_at IS NULL
ORDER BY created_at DESC
`

func (q *Queries) DemoGetByUser(ctx context.Context, userID int32) ([]Demo, error) {
	rows, err := q.db.Query(ctx, demoGetByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Demo
	for rows.Next() {
		var i Demo
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Source,
			&i.SourceID,
			&i.FileID,
			&i.Status,
			&i.Attempts,
			&i.Error,
			&i.CreatedAt,
			&i.StatusUpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const demoResetStatusAll = `-- name: DemoResetStatusAll :exec
UPDATE demos
SET 
  status = $1,
  status_updated_at = NOW()
WHERE
  status = $2
`

type DemoResetStatusAllParams struct {
	NewStatus DemoStatus
	OldStatus DemoStatus
}

func (q *Queries) DemoResetStatusAll(ctx context.Context, arg DemoResetStatusAllParams) error {
	_, err := q.db.Exec(ctx, demoResetStatusAll, arg.NewStatus, arg.OldStatus)
	return err
}

const demoUpdateFile = `-- name: DemoUpdateFile :exec
UPDATE demos
SET file_id = $2
WHERE id = $1
`

type DemoUpdateFileParams struct {
	ID     int32
	FileID pgtype.Text
}

func (q *Queries) DemoUpdateFile(ctx context.Context, arg DemoUpdateFileParams) error {
	_, err := q.db.Exec(ctx, demoUpdateFile, arg.ID, arg.FileID)
	return err
}

const demoUpdateStatus = `-- name: DemoUpdateStatus :exec
UPDATE demos
SET
  status = $2,
  error = $3,
  status_updated_at = NOW()
WHERE id = $1
`

type DemoUpdateStatusParams struct {
	ID     int32
	Status DemoStatus
	Error  pgtype.Text
}

func (q *Queries) DemoUpdateStatus(ctx context.Context, arg DemoUpdateStatusParams) error {
	_, err := q.db.Exec(ctx, demoUpdateStatus, arg.ID, arg.Status, arg.Error)
	return err
}
